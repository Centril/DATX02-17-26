---- Mazdak start:

entrypoints Program ;

Program. Program ::= Identifier ;

--------------------------------------------------------------------------------
-- Productions from §4 (Types, Values, and Variables)
--------------------------------------------------------------------------------

-- TODO: fix this, later...
Annotation. Annotation ::= ;
separator Annotation "" ;

-- TODO: fix this, later...
Id. Identifier ::= Ident;

{-
integralType
	:	'byte'
	|	'short'
	|	'int'
	|	'long'
	|	'char'
	;
-}

-- Integral types:
TByte.   IntegralType ::= "byte"  ;
TShort.  IntegralType ::= "short" ;
TInt.    IntegralType ::= "int"   ;
TLong.   IntegralType ::= "long"  ;
TChar.   IntegralType ::= "char"  ;

{-
floatingPointType
	:	'float'
	|	'double'
	;
-}

-- Floating types:
TFloat.  FloatingType ::= "float"  ;
TDouble. FloatingType ::= "double" ;

{-
numericType
	:	integralType
	|	floatingPointType
	;
-}

-- Numeric Types:
TIntegral. NumericType  ::= IntegralType ;
TFloating. NumericType  ::= FloatingType ;

{-
primitiveType
	:	annotation* numericType
	|	annotation* 'boolean'
	;
-}

-- Primitive Types:
TNumeric.  PrimitiveType ::= [Annotation] NumericType ;
TBool.     PrimitiveType ::= [Annotation] "boolean" ;

{-
referenceType
	:	classOrInterfaceType
	|	typeVariable
	|	arrayType
	;
-}

TRClassIface. ReferenceType ::= CIType         ;
TTypeVar.     ReferenceType ::= TypeVariable   ;
TArrayType.   ReferenceType ::= ArrayType      ;

ClassCIType. CIType ::= ClassType ;
IfaceCIType. CIType ::= IfaceType ;

TopCT.   ClassType ::= [Annotation] Identifier MTypeArgs ;
InnerCT. ClassType ::= CIType "." [Annotation] Identifier MTypeArgs ;

IfaceType. IfaceType ::= ClassType ;

{-
typeVariable
    :   annotation* Identifier
    ;
-}

TypeVar. TypeVariable ::= [Annotation] Identifier ;

{-
arrayType
    :   primitiveType dims
    |   classOrInterfaceType dims
    |   typeVariable dims
    ;
-}

PrimArrType. ArrayType ::= PrimitiveType [Dim] ;
CIArrType.   ArrayType ::= CIType [Dim] ;
TVArrType.   ArrayType ::= TypeVariable [Dim] ;

{-
dims
	:	annotation* '[' ']' (annotation* '[' ']')*
	;
-}

Dim. Dim ::= [Annotation] "[" "]" ;
separator nonempty Dim "" ;

{-
typeParameter
	:	typeParameterModifier* Identifier typeBound?
	;
-}
TypeParam. TypeParameter ::= [TypeParamModif] Identifier MTypeBound ;

{-
typeParameterModifier
	:	annotation
	;
-}

TypeParamModif.  TypeParamModif  ::= Annotation ;
separator TypeParamModif "" ;

{-
typeBound
	:	'extends' typeVariable
	|	'extends' classOrInterfaceType additionalBound*
	;
-}

JTypeBound. MTypeBound ::= TypeBound ;
NTypeBound. MTypeBound ::= ;
TBTypVar. TypeBound ::= "extends" TypeVariable ;
TBAddit.  TypeBound ::= "extends" CIType [AdditionalBound] ;

{-
additionalBound
	:	'&' interfaceType
	;
-}

AdditionalBound. AdditionalBound ::= "&" IfaceType ;
separator AdditionalBound "" ;

{-
typeArguments
	:	'<' typeArgumentList '>'
	;
-}

JTypeArgs. MTypeArgs ::= TypeArgs ;
NTypeArgs. MTypeArgs ::= ;
TypeArgs.  TypeArgs ::= "<" [TypeArg] ">" ;

{-
typeArgumentList
    :   typeArgument (',' typeArgument)*
    ;

typeArgument
    :   referenceType
    |   wildcard
    ;
-}

TArgRef. TypeArg ::= ReferenceType ;
TArgWC.  TypeArg ::= Wildcard ;
separator nonempty TypeArg "," ;

{-
wildcard
	:	annotation* '?' wildcardBounds?
	;
-}

Wildcard. Wildcard ::= [Annotation] "?" MWildcardBounds ;

{-
wildcardBounds
    :   'extends' referenceType
    |   'super' referenceType
;
-}

JWBounds. MWildcardBounds ::= WildcardBounds ;
NWBounds. MWildcardBounds ::= ;

WBExtends. WildcardBounds ::= "extends" ReferenceType ;
WBSuper.   WildcardBounds ::= "super"   ReferenceType ;

{-
type
	:	primitiveType
	|	referenceType
	;
-}

TPrim. Type ::= PrimitiveType ;
TRef.  Type ::= ReferenceType ;




---- Alex start:
{-
/*
 * Productions from §6 (Names)
 */

packageName
	:	Identifier
	|	packageName '.' Identifier
	;
-}

PackIdent.  Package ::= Id ;
PackDotId.  Package ::= Package "." Id ;

{-
typeName
	:	Identifier
	|	packageOrTypeName '.' Identifier
;
-}

TypeNameId. TypeName ::= Id ;
PorTDotId.  TypeName ::= PackOrType "." Id ;

{-
packageOrTypeName
	:	Identifier
	|	packageOrTypeName '.' Identifier
;
-}

PackOrTypeId. PackOrType ::= Id ;
POrTNDotId.   PackOrType ::= PackOrType "." Id ;

{-expressionName
	:	Identifier
	|	ambiguousName '.' Identifier
;
-}

ExpNamId.    ExpName ::= Id ;
AmbNamId.    ExpName ::= AmbName "." Id ;

{-
methodName
	:	Identifier
;
-}

MetNam.    MethodName ::= Id ;

{-
ambiguousName
	:	Identifier
	|	ambiguousName '.' Identifier
;
-}

AmbId.     AmbName ::= Id ;
AmbNamId.  AmbName ::= AmbName "." Id ;

{-
/*
 * Productions from §7 (Packages)
 */
-}

{-
compilationUnit
	:	packageDeclaration? importDeclaration* typeDeclaration* EOF
;
-}

--MIGHT BE WRONG!!
CompUni.  ComUnit ::= PackDec [ImpDec] [TypDec] ;

{-
packageDeclaration
	:	packageModifier* 'package' Identifier ('.' Identifier)* ';'
;
-}
PDec.     PackDec ::= [PackModi] "package" Id ["." Id] ";" ;

{-
packageModifier
	:	annotation
;
-}

PMod.     PackModi ::= Annotation ;

{-
importDeclaration
	:	singleTypeImportDeclaration
	|	typeImportOnDemandDeclaration
	|	singleStaticImportDeclaration
	|	staticImportOnDemandDeclaration
;
-}
SingImp.  ImpDec ::= SingImpDec ;
TypImp.   ImpDec ::= TypImpDec ;
SiStI.    ImpDec ::= SiStatDec ;
StatImp.  ImpDec ::= StatImpDec ;
separator ImpDec ";" ;

{-
singleTypeImportDeclaration
	:	'import' typeName ';'
;
-}
SiTypIm.  SingImpDec ::= "import" TypeName ";" ;

{-
typeImportOnDemandDeclaration
	:	'import' packageOrTypeName '.' '*' ';'
;
-}
TyImDec.  TypImpDec ::= "import" PackOrType "." "*" ";" ;

{-

singleStaticImportDeclaration
	:	'import' 'static' typeName '.' Identifier ';'
;
-}
SiStImp.   SiStatDec ::= "import" "static" TypeName "." Id ";" ;

{-
staticImportOnDemandDeclaration
	:	'import' 'static' typeName '.' '*' ';'
;
-}
StImpDec.  StatImpDec ::= "import" "static" TypeName "." "*" ";" ;

{-
typeDeclaration
	:	classDeclaration
	|	interfaceDeclaration
	|	';'
;
-}

TClDec.   TypDec ::= ClassDec ;
InFaDec.  TypDec ::= IntrfcDec ;
--ETyDe.    TypDec ::= ";"
separator TypDec ";" ;

{-
/*
 * Productions from §8 (Classes)
 */
 -}

{-
classDeclaration
	:	normalClassDeclaration
	|	enumDeclaration
;
-}

NCDe.    ClassDec ::= NCDec ;
EnDe.    ClassDec ::= EnDec ;

{-
normalClassDeclaration
	:	classModifier* 'class' Identifier typeParameters? superclass? superinterfaces? classBody
;
-}
NCDe.    NCDec ::= [CMod] "class" Id  TypParams SupCla SupIntr CBod ;

{-
	classModifier
	:	annotation
	|	'public'
	|	'protected'
	|	'private'
	|	'abstract'
	|	'static'
	|	'final'
	|	'strictfp'
;
-}
CAnn.   CMod ::= Annotation ;
CPub.   CMod ::= "public" ;
CPro.   CMod ::= "protected" ;
CPri.   CMod ::= "private" ;
CAbs.   CMod ::= "abstract" ;
CSta.   CMod ::= "static" ;
CFin.   CMod ::= "final" ;
CSFp.   CMod ::= "strictfp" ;

{-
typeParameters
	:	'<' typeParameterList '>'
;
-}
TPar.   TypeParams ::= "<" [TypeParameter] ">" ;
TPEm.   TypeParams ::= ;


{-
typeParameterList
	:	typeParameter (',' typeParameter)*
;
-}
separator TypeParameter "," ;

{-
superclass
	:	'extends' classType
;
-}

SCla.   SupCla ::= "extends" ClassType ;








---- Joel + Brage start:

-------------------------------------------------------------------------------
-- Productions from §14 (Blocks and Statements)
-------------------------------------------------------------------------------


{-
block
	:	'{' blockStatements? '}'
	;
-}

Block. Block ::= "{" MBlockStatements "}" ;

JBlockStatements. MBlockStatements ::= BlockStatements ;
NBlockStatements. MBlockStatements ::= ;

{-

blockStatements
	:	blockStatement blockStatement*
	;

blockStatement
	:	localVariableDeclStatement
	|	classDecl
	|	statement
	;

-}

BlockStatements. BlockStatements ::= BlockStatement [BlockStatement] ;

LocalVariableDeclStatement. 	BlockStatement ::= LocalVariableDeclStatement;
ClassDecl.	 					BlockStatement ::= ClassDecl;
Statement. 						BlockStatement ::= Statement;
separator BlockStatement "" ;

{-

localVariableDeclStatement
	:	localVariableDecl ';'
	;

-}

LocalVariableDecl. LocalVariableDeclStatement ::= LocalVariableDecl ";" ;

{-

localVariableDecl
	:	variableModifier* unannType variableDeclaratorList
	;

-}

LocalVarDecl. 	LocalVariableDecl ::= [VariableModifier] UnannType VariableDeclaratorList ;

{-

statement
	:	statementWithoutTrailingSubstatement
	|	labeledStatement
	|	ifThenStatement
	|	ifThenElseStatement
	|	whileStatement
	|	forStatement
	;

	-}

StatementWoTrail. 	Statement ::= StatementWithoutTrailingSubstatement ;
LbldStatement. 		Statement ::= LabeledStatement ;
IfThenStn.			Statement ::= IfThenStatement ;
IfElseStn.			Statement ::= IfThenElseStatement ;
WhileStn.			Statement ::= WhileStatement ;
ForStn.				Statement ::= ForStatement ;

	{-

statementNoShortIf
	:	statementWithoutTrailingSubstatement
	|	labeledStatementNoShortIf
	|	ifThenElseStatementNoShortIf
	|	whileStatementNoShortIf
	|	forStatementNoShortIf
	;

	-}

NoIfWoTrail. 	StatementNoShortIf ::= StatementWithoutTrailingSubstatement ;
LbldStnNSIf. 	StatementNoShortIf ::= LabeledStatementNoShortIf ;
IfElseStnNSIf. 	StatementNoShortIf ::= IfThenElseStatementNoShortIf ;
WhileStnNSIf.	StatementNoShortIf ::= WhileStatementNoShortIf ;
ForStnNSIf. 	StatementNoShortIf ::= ForStatementNoShortIf ;

{-
statementWithoutTrailingSubstatement
	:	block
	|	emptyStatement
	|	expressionStatement
	|	assertStatement
	|	switchStatement
	|	doStatement
	|	breakStatement
	|	continueStatement
	|	returnStatement
	|	synchronizedStatement
	|	throwStatement
	|	tryStatement
	;

-}

BlockWoTrail.		StatementWithoutTrailingSubstatement ::= Block ;
EmptyStnWoTrail.	StatementWithoutTrailingSubstatement ::= EmptyStatement ;
ExprStnWoTrail.		StatementWithoutTrailingSubstatement ::= ExpressionStatement ;
AssertStnWoTrail.	StatementWithoutTrailingSubstatement ::= AssertStatement ;
SwitchStnWoTrail.	StatementWithoutTrailingSubstatement ::= SwitchStatement ;
DoStnWoTrail.		StatementWithoutTrailingSubstatement ::= DoStatement ;
BreakStnWoTrail.	StatementWithoutTrailingSubstatement ::= BreakStatement ;
ContStnWoTrail.		StatementWithoutTrailingSubstatement ::= ContinueStatement ;
RtnStnWoTrail.		StatementWithoutTrailingSubstatement ::= ReturnStatement ;
SynchStnWoTrail.	StatementWithoutTrailingSubstatement ::= SynchronizedStatement ;
ThrowStnWoTrail.	StatementWithoutTrailingSubstatement ::= ThrowStatement ;
TryStnWoTrail.		StatementWithoutTrailingSubstatement ::= TryStatement ;

{-

emptyStatement
	:	';'
	;

-}

EmptyStn. EmptyStatement ::= ";" ;

{-

labeledStatement
	:	Identifier ':' statement
	;

-}

LblStn. LabeledStatement ::= Identifier ":" Statement ;

{-

labeledStatementNoShortIf
	:	Identifier ':' statementNoShortIf
	;

-}

IdStnNSIf. LabeledStatementNoShortIf ::= Identifier ":" StatementNoShortIf ;

{-
expressionStatement
	:	statementExpression ';'
	;
-}

StnExp. ExpressionStatement ::= StatementExpression ";" ;

{-
statementExpression
	:	assignment
	|	preIncrementExpression
	|	preDecrementExpression
	|	postIncrementExpression
	|	postDecrementExpression
	|	methodInvocation
	|	classInstanceCreationExpression
	;
-}

AssignExpr. 			StatementExpression ::= Assignment ;
PreIncrExpr. 			StatementExpression ::= PreIncrementExpression;
PreDecrExpr. 			StatementExpression ::= PreDecrementExpression;
PostIncrExpr. 			StatementExpression ::= PostIncrementExpression;
PostDecrExpr. 			StatementExpression ::= PostDecrementExpression;
MethodInvocationExpr. 	StatementExpression ::= MethodInvocation;
ClassInstCreationExpr. 	StatementExpression ::= ClassInstanceCreationExpression;

{-
ifThenStatement
	:	'if' '(' expression ')' statement
	;
-}

IfThenStatement. IfThenStatement ::= "if" "(" Expression ")" Statement ;

{-
ifThenElseStatement
	:	'if' '(' expression ')' statementNoShortIf 'else' statement
	;
-}

IfThenElseStatement. IfThenElseStatement ::= "if" "(" Expression ")" StatementNoShortIf "else" Statement ;

{-
ifThenElseStatementNoShortIf
	:	'if' '(' expression ')' statementNoShortIf 'else' statementNoShortIf
	;
-}

IfThenElseStatementNoShortIf. IfThenElseStatementNoShortIf ::= "if" "(" Expression ")" StatementNoShortIf "else" StatementNoShortIf ;

{-
assertStatement
	:	'assert' expression ';'
	|	'assert' expression ':' expression ';'
	;
-}

AssertExpr. 	AssertStatement ::= "assert" Expression ";" ;
AssertExprExpr. AssertStatement ::= "assert" Expression ":" Expression ";" ;

{-
switchStatement
	:	'switch' '(' expression ')' switchBlock
	;
-}

SwitchStatement. SwitchStatement ::= "switch" "(" Expression ")" SwitchBlock ;
 
{-
switchBlock
	:	'{' switchBlockStatementGroup* switchLabel* '}'
	;
-}

SwitchBlock. SwitchBlock ::= "{" [SwitchBlockStatementGroup] [SwitchLabel] "}" ;

{-
switchBlockStatementGroup
	:	switchLabels blockStatements
	;
-}

SwitchBlockStatementGroup. SwitchBlockStatementGroup ::= SwitchLabels BlockStatements ;

{-
switchLabels
	:	switchLabel switchLabel*
	;
-}

SwitchLabels. SwitchLabels ::= SwitchLabel [SwitchLabel] ;

{-
switchLabel
	:	'case' constantExpression ':'
	|	'case' enumConstantName ':'
	|	'default' ':'
	;
-}

ConstantSwitchLabel. SwitchLabel ::= "case" ConstantExpression ":" ;
EnumSwitchLabel. SwitchLabel ::= "case" EnumConstantName ":" ;
DefaultSwitchLabel. SwitchLabel ::= "default" ":" ;

{-
enumConstantName
	:	Identifier
	;
-}

EnumConstantName. EnumConstantName ::= Identifier ;

{-
whileStatement
	:	'while' '(' expression ')' statement
	;
-}

WhileStatement. WhileStatement ::= "while" "(" Expression ")" Statement ;

{-
whileStatementNoShortIf
	:	'while' '(' expression ')' statementNoShortIf
	;
-}

WhileStatementNSIf. WhileStatementNoShortIf ::= "while" "(" Expression ")" StatementNoShortIf ;

{-
doStatement
	:	'do' statement 'while' '(' expression ')' ';'
	;
-}

DoStatement. DoStatement ::= "do" Statement "while" "(" Expression ")" ";" ;

{-
forStatement
	:	basicForStatement
	|	enhancedForStatement
	;

forStatementNoShortIf
	:	basicForStatementNoShortIf
	|	enhancedForStatementNoShortIf
	;

basicForStatement
	:	'for' '(' forInit? ';' expression? ';' forUpdate? ')' statement
	;

basicForStatementNoShortIf
	:	'for' '(' forInit? ';' expression? ';' forUpdate? ')' statementNoShortIf
	;

forInit
	:	statementExpressionList
	|	localVariableDecl
	;

forUpdate
	:	statementExpressionList
	;

-}

ForStatementBasic. 		ForStatement ::= BasicForStatement ;
ForStatementEnhanced. 	ForStatement ::= EnhancedForStatement ;

ForBasicNSIf. 		ForStatementNoShortIf ::= BasicForStatementNoShortIf ;
ForEnhancedNSIf. 	ForStatementNoShortIf ::= EnhancedForStatementNoShortIf ;

BasicForStatement. 		BasicForStatement ::= "for" "(" MForInit ";" MExpr ";" MForUpdate ")" Statement ;
BasicForStatementNSIf. 	BasicForStatement ::= "for" "(" MForInit ";" MExpr ";" MForUpdate ")" StatementNoShortIf ;

JForInit. MForInit ::= ForInit ;
NForInit. MForInit ::= ;

ForInitExps.	ForInit ::=	StatementExpressionList ;
ForInitVarDecl.	ForInit ::=	LocalVariableDecl ;

JForUpdate. MForUpdate ::= ForUpdate ;
NForUpdate. MForUpdate ::= ;

ForUpdateExps.	ForUpdate ::=	StatementExpressionList ;

{-

statementExpressionList
	:	statementExpression (',' statementExpression)*
	;

enhancedForStatement
	:	'for' '(' variableModifier* unannType variableDeclaratorId ':' expression ')' statement
	;

enhancedForStatementNoShortIf
	:	'for' '(' variableModifier* unannType variableDeclaratorId ':' expression ')' statementNoShortIf
	;

breakStatement
	:	'break' Identifier? ';'
	;

continueStatement
	:	'continue' Identifier? ';'
	;

returnStatement
	:	'return' expression? ';'
	;

throwStatement
	:	'throw' expression ';'
	;

synchronizedStatement
	:	'synchronized' '(' expression ')' block
	;

tryStatement
	:	'try' block catches
	|	'try' block catches? finally_
	|	tryWithResourcesStatement
	;

catches
	:	catchClause catchClause*
	;

catchClause
	:	'catch' '(' catchFormalParameter ')' block
	;

catchFormalParameter
	:	variableModifier* catchType variableDeclaratorId
	;

catchType
	:	unannClassType ('|' classType)*
	;

finally_
	:	'finally' block
	;

tryWithResourcesStatement
	:	'try' resourceSpecification block catches? finally_?
	;

resourceSpecification
	:	'(' resourceList ';'? ')'
	;

resourceList
	:	resource (';' resource)*
	;

resource
	:	variableModifier* unannType variableDeclaratorId '=' expression
	;

-}


--class declarations
JClass. Class ::= [Modif] "class" Id "{" [Decl] "}" ;

--visibility levels
Pub.    Modif ::= "public" ;
Priv.   Modif ::= "private" ;
Prot.   Modif ::= "protected" ;
Stat.   Modif ::= "static" ;
separator Modif " " ;

--Unsp.   Visib ::=  ;

--UVis.   UVisib ::= ;

--instance type for methods

--MUns.    MInsTyp ::= ;

--instance type for vars
--VStat.  VInsTyp ::= "static" ;
--VUns.   VInsTyp ::= ;

--VIDecl.  FDec ::= Visib ;
--IVDecl.  FDec ::= MInsTyp ;
--EDecl.   FDec ::= ;
--UMVDec. FDec ::= UVisib MInsTyp Visib ;
--VMDec.  FDec ::= Visib MInsTyp ;
--UMDec.  FDec ::= UVisib MInsTyp ;

--coercions FDec 2 ;

--Declarations 
MDecl.  Decl ::= [Modif] Type Id "(" [Arg] ")" "{" [Stm] "}" ;
VDecl.  Decl ::= [Modif] Type [VarDecl]  ";" ;
--VIDecl. Decl ::= [Modif] Type Id "=" Exp ;  
terminator Decl "" ;

VDec.	 VarDecl ::= DeclName ;
VDecE.   VarDecl ::= DeclName "=" Exp ;
separator VarDecl "," ;

VDecNa.	DeclName ::= Id ;
VDecAr.	DeclName ::= Id [Bracket] ;

Bra.	Bracket ::= "[]" ;
separator nonempty Bracket "" ;

--Types
TInt.    BasicType ::= "int" ;
TDouble. BasicType ::= "double" ;
TFloat.  BasicType ::= "float" ;
TChar.   BasicType ::= "char" ;
TBool.   BasicType ::= "boolean" ;
TShort.  BasicType ::= "short" ;
TByte.   BasicType ::= "byte" ;

BAType.  Type ::= BasicType [Bracket] ;
BType.   Type ::= BasicType ;

MArg.	Arg ::= Type DeclName ;
separator Arg "," ;

--Statements
StE.	  Stm ::= Exp ;
StReturn. Stm ::= "return" Exp ;
StCond.   Stm ::= "if" "(" Exp ")" Stm Rest ;
StFor.    Stm ::= ForLoop ;
StWhile.  Stm ::= "while" "(" Exp ")" Stm ;
StBlock.  Stm ::= "{" [Stm] "}" ;
separator Stm ";" ;

REsle.    Rest ::= "else" Stm ;
REmpty.   Rest ::= ;

--For loop, separeted as there are different for loops
IncFor. ForLoop ::= "for" "(" ForInit ";" Exp ";" Exp ")" Stm ;

--As for loops has the same rules (ish) as variable declaration there are a lot of special cases
ForExp.   ForInit ::= [Exp] ;
ForVDecl. ForInit ::= Type [VarDecl] ;
ForFinal. ForInit ::= "final" Type [VarDecl] ;

--Expressions
EFunc.		Exp15  ::= Exp16 "(" [Exp] ")" ;
EIndex.     Exp15  ::= Exp16 "[" Exp "]";

EPoint.		Exp14  ::= Exp14 "->" Exp15 ;
EStruVar.	Exp14  ::= Exp14 "." Exp15 ;
EPosIncr.	Exp14  ::= Exp15 "++" ;
EPosDecr.  	Exp14  ::= Exp15 "--" ;

EPrIncr.   	Exp13  ::= "++" Exp14 ;
EPrDecr.   	Exp13  ::= "--" Exp14 ;
ENeg.    	Exp13  ::= "*" Exp14 ;
ENega.    	Exp13  ::= "!" Exp14 ;

EMul.    	Exp12  ::= Exp12 "*"  Exp13 ;
EDiv.   	Exp12  ::= Exp12 "/"  Exp13 ;
EMod.   	Exp12  ::= Exp12 "%"  Exp13 ;

EAdd.   	Exp11  ::= Exp11 "+"  Exp12 ;
ESub.    	Exp11  ::= Exp11 "-"  Exp12 ;

ELShift.	Exp10  ::= Exp10 "<<" Exp11 ;
ERShift.	Exp10  ::= Exp10 ">>" Exp11 ;

ELt.    	Exp9   ::= Exp9  "<"  Exp10 ;
EGt.     	Exp9   ::= Exp9  ">"  Exp10 ;
ELEq.    	Exp9   ::= Exp9  "<=" Exp10 ;
EGEq.    	Exp9   ::= Exp9  ">=" Exp10 ;

EEq.     	Exp8   ::= Exp8  "==" Exp9 ;
ENEq.    	Exp8   ::= Exp8  "!=" Exp9 ;

EAnd.    	Exp4   ::= Exp4  "&&" Exp5 ;

EOr.     	Exp3   ::= Exp3  "||" Exp4 ;

EAss.    	Exp2   ::= Exp3 "=" Exp2 ;
EPAss.		Exp2   ::= Exp3 "+=" Exp2 ;
ENAss.		Exp2   ::= Exp3 "-=" Exp2 ;
ECond.		Exp2   ::= Exp3 "?" Exp2 ":" Exp2 ;

Ethr.		Exp1	::= "throw" Exp2 ;

coercions 	Exp 16 ;
separator Exp "," ;


token Id (letter (letter | digit | '_')*) ;

separator nonempty Id "," ; 
